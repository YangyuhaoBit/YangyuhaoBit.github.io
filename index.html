<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="杨宇豪的个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="杨宇豪的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="杨宇豪的个人博客">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> 杨宇豪的个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">杨宇豪的个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/浅析Redux原理/" itemprop="url">
                  浅析Redux源码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-10-10T10:06:05+08:00" content="2016-10-10">
              2016-10-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>个人觉得，学习一个<code>JS</code>框架，最好的办法就是用原生<code>JS</code>将它的功能实现一遍。如果你已经读过一些关于<code>Redux</code>的简介却又感觉不知所云，那么本文是最适合你的。</p>
<p>本文会用原生<code>JS</code>实现一个简版<code>Redux</code>，代码仅用于学习，不保证实际运行效果。</p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p><code>reducer</code>是一个处理函数，在<code>createStore(reducer)</code>中作为参数传入,，它会返回一个新的<code>state</code>。<code>reducer</code>的用法为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reducer(state, action);</div></pre></td></tr></table></figure></p>
<p>其中<code>action</code>为一个对象，它必须有一个属性<code>action.type</code>来指明操作的类型。</p>
<p>在<code>reducer</code>中，我们会预先设置一些操作，当<code>reducer</code>运行时，一般通过一个<code>switch</code>操作来判断<code>action.type</code>的值，并执行对应的操作。</p>
<p>例如，我们现在来定义一个名为<code>counter</code>的<code>reducer</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">const counter = (state = 0, action)=&gt; &#123;</div><div class="line">    if (!action) &#123;</div><div class="line">        return state;</div><div class="line">    &#125;</div><div class="line">    switch (action.type) &#123;</div><div class="line">        case &apos;inc&apos;:</div><div class="line">            return state + 1;</div><div class="line">            break;</div><div class="line">        case &apos;dec&apos;:</div><div class="line">            return state - 1;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return state;</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">console.log(counter(undefined, &#123;type: &apos;inc&apos;&#125;)); // 输出1</div><div class="line">console.log(counter(10, &#123;type: &apos;dec&apos;&#125;)); // 输出9</div></pre></td></tr></table></figure></p>
<p>在这个<code>reducer</code>中，我们将<code>state</code>的默认值设为0，如果<code>action.type</code>为<code>inc</code>、<code>dec</code>，则执行对应的操作，否则直接将<code>state</code>返回即可。</p>
<h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><p><code>createStore(reducer)</code>接受一个<code>reducer</code>为参数，返回一个<code>store</code>对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">const createStore(reducer)&#123;</div><div class="line">    let state;</div><div class="line">    const getState()=&gt;&#123;&#125;;</div><div class="line">    const dispatch()=&gt;&#123;&#125;;</div><div class="line">    const subscribe()=&gt;&#123;&#125;;</div><div class="line">    return &#123;</div><div class="line">        getState,</div><div class="line">        dispatch,</div><div class="line">        subscribe</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>createStore</code>会在函数内部定义<code>state</code>，这样一来根据闭包的原理，只有<code>createStore</code>内部定义的方法才能更改<code>state</code>。这就实现了<code>Redux</code>的三大原则</p>
<ol>
<li>单一数据源</li>
<li>State 是只读的</li>
<li>使用纯函数来执行修改</li>
</ol>
<p>关于<code>Redux</code>的三大原则，请参考<a href="http://redux.js.org/" target="_blank" rel="external">这里</a>，或<a href="https://github.com/camsong/redux-in-chinese" target="_blank" rel="external">中文文档</a></p>
<p><code>store</code>上面包括三个方法<code>getState</code>、<code>dispatch</code>、<code>subscribe</code>，下面分别讲解这三个方法。</p>
<h3 id="getState"><a href="#getState" class="headerlink" title="getState"></a>getState</h3><p><code>getState</code>会返回当前状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">const getState = ()=&gt; &#123;</div><div class="line">    return state;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h3><p><code>dispatch</code>用来修改<code>state</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const dispatch = (action)=&gt; &#123;</div><div class="line">    state = reducer(state, action);</div><div class="line">    return action; // dispatch会将action返回</div><div class="line">&#125;;</div><div class="line">dispatch();</div></pre></td></tr></table></figure></p>
<p><code>dispatch</code>会调用<code>reducer</code>，即使用<code>createStore(reducer)</code>时传入的参数，同时<code>dispatch</code>也需要一个<code>action</code>对象作为参数，并将这个<code>action</code>对象传入<code>reducer</code>。</p>
<p><code>createStore</code>内部会自动调用一次<code>dispatch()</code>，不传入任何参数，因此在创建<code>store</code>后，<code>state</code>的值就为<code>reducer</code>设置的<code>state</code>默认值，以上面创建的<code>counter</code>为例，此时<code>state</code>为0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let store = createStore(counter);</div><div class="line">console.log(store.getState()); // 输出0</div><div class="line">store.dispatch(&#123;type: &apos;inc&apos;&#125;);</div><div class="line">console.log(store.getState()); // 输出1</div><div class="line">store.dispatch(&#123;type: &apos;dec&apos;&#125;);</div><div class="line">console.log(store.getState()); // 输出0</div></pre></td></tr></table></figure></p>
<p>这样一来，我们就实现了通过<code>dispatch</code>和<code>reducer</code>修改<code>state</code>。</p>
<h3 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h3><p><code>subscribe</code>是用来绑定事件监听的，监听<code>state</code>的改变事件，类似于（就是）事件的发布订阅模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let listeners = [];</div><div class="line">const subscribe = (listener)=&gt; &#123;</div><div class="line">    listeners.push(listener);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>createStore</code>内部再定义一个内部数组<code>listeners</code>，每次调用<code>subscribe</code>都会将传入的<code>listener</code>添加到<code>listeners</code>数组中。</p>
<p>因为状态的改变只可能在<code>dispatch</code>中发生，所以为了实现监听，我们还需要在<code>dispatch</code>中发布事件。修改<code>dispatch</code>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const dispatch = (action)=&gt; &#123;</div><div class="line">    state = reducer(state, action);</div><div class="line">    listeners.forEach(listener =&gt; listener()); // 发布事件</div><div class="line">    return action;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>同时，为了能够取消事件订阅，需要一个取消接口，<code>Redux</code>在这里运用了一点纯函数的概念。修改<code>subscribe</code>函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const subscribe = (listener)=&gt; &#123;</div><div class="line">    listeners.push(listener);</div><div class="line">    return function () &#123;</div><div class="line">        listeners = listeners.filter(fn =&gt; fn != listener);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样在调用时用一个变量来接受函数即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let unsubscribe = store.subscribe(listener);</div></pre></td></tr></table></figure></p>
<p>这个<code>unsubscribe</code>函数可以将刚才订阅的事件取消。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>这样一来，<code>Redux</code>的基本功能就实现了。我们可以写一个小demo来验证一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let store = createStore(counter);</div><div class="line">const render = ()=&gt; &#123; // 实现一个简单的viewRender</div><div class="line">    document.body.innerHTML = store.getState();</div><div class="line">&#125;;</div><div class="line">render();</div><div class="line">let unsubscribe = store.subscribe(function()&#123; // 监听state的改变</div><div class="line">    render(); // 状态改变后重新渲染view</div><div class="line">    if(store.getState() == 10)&#123;</div><div class="line">        unsubscribe();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">document.addEventListener(&apos;click&apos;, function () &#123; // 用户行为触发dispatch</div><div class="line">    store.dispatch(&#123;type: &apos;inc&apos;&#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>将代码放到浏览器运行即可。</p>
<h2 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h2><p>这是<code>redux</code>中<code>middleware</code>的源代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">import compose from &apos;./compose&apos;;</div><div class="line">function applyMiddleware(...middlewares) &#123;</div><div class="line">    return (next) =&gt; (reducer, initialState) =&gt; &#123;</div><div class="line">        let store = next(reducer, initialState);</div><div class="line">        let dispatch = store.dispatch;</div><div class="line">        let chain = [];</div><div class="line"></div><div class="line">        let middlewareAPI = &#123;</div><div class="line">            getState: store.getState,</div><div class="line">            dispatch: (action) =&gt; dispatch(action)</div><div class="line">        &#125;;</div><div class="line">        chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</div><div class="line">        dispatch = compose(...chain)(store.dispatch);</div><div class="line"></div><div class="line">        return Object.assign(&#123;&#125;,store,&#123;dispatch&#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来分别讲解这些代码都是做什么的</p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p><code>compose</code>是<code>middleware</code>唯一依赖的组件，在上面的代码中，只有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch = compose(...chain)(store.dispatch);</div></pre></td></tr></table></figure></p>
<p>这一行使用了这个方法，可以理解为使用<code>chain</code>数组中的每一个函数装饰了<code>store.dispatch</code>，如果你对这些底层代码不感兴趣，也可跳过这一部分</p>
<p>先假设现在有几个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function fn1() &#123;</div><div class="line">    console.log(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fn2() &#123;</div><div class="line">    console.log(2)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fn3() &#123;</div><div class="line">    console.log(3)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要求写一个函数，把上面几个函数按下面的方式排列返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function fn1() &#123;</div><div class="line">    console.log(1);</div><div class="line">    return function fn2() &#123;</div><div class="line">        console.log(2);</div><div class="line">        return function fn3() &#123;</div><div class="line">            console.log(3)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，只要运行<code>fn1</code>，就可以同时运行<code>fn2</code>和<code>fn3</code>了，相当于<code>fn2</code>装饰了<code>fn3</code>，<code>fn1</code>装饰了<code>fn2</code></p>
<p>为了实现这一需求，需要对上面的每个<code>function</code>之外再包裹一个函数，这个函数有一个<code>next</code>参数，<code>next</code>为上一个函数的返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function _fn1(next)&#123;</div><div class="line">    return function fn1() &#123;</div><div class="line">        console.log(1);</div><div class="line">        return next(); // 这里的next为_fn2的返回值，即fn2</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function _fn2(next)&#123;</div><div class="line">    return function fn2() &#123;</div><div class="line">        console.log(2);</div><div class="line">        return next(); // 这里的next为fn3</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fn3()&#123; // 最后一个函数不需要改动</div><div class="line">    console.log(3);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就可以实现我们的需求。但是怎么让每个函数的<code>next</code>都指向上一个函数的返回值呢？这里需要用到数组的<code>reduce</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let funcs = [_fn1, _fn2];</div><div class="line"></div><div class="line">funcs.reverse();</div><div class="line"></div><div class="line">let newFunc = funcs.reduce(function (next, fn) &#123;</div><div class="line">    return fn(next);</div><div class="line">&#125;, fn3);</div><div class="line"></div><div class="line">newFunc(); // 依次输出1,2,3</div></pre></td></tr></table></figure></p>
<p>关于数组的<code>reduce</code>方法请参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">这里</a>，本文不做过多介绍</p>
<p>对上面的过程进行函数封装，就成为了<code>redux</code>中的<code>compose</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function compose(...funcs) &#123;</div><div class="line"></div><div class="line">    if (funcs.length === 0) &#123;</div><div class="line">        return function (arg) &#123;</div><div class="line">            return arg;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (funcs.length === 1) &#123;</div><div class="line">        return funcs[0];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    funcs.reverse();</div><div class="line"></div><div class="line">    let first = funcs[0]; // 第一个函数可以传递多个参数，因此需要单独处理</div><div class="line">    var rest = funcs.slice(1);</div><div class="line">    return function () &#123;</div><div class="line">        return rest.reduce(function (composed, f) &#123;</div><div class="line">            return f(composed);</div><div class="line">        &#125;, first.apply(undefined, arguments));</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用<code>compose</code>后，会返回一个函数，这个函数的第一个参数会作为第一个函数的<code>next</code>参数传入</p>
<p>将上面例子中的三个<code>function</code>使用<code>compose</code>来组合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let newFunc = compose(_fn1, _fn2)(fn3);</div><div class="line"></div><div class="line">newFunc(); // 依次输出1,2,3</div></pre></td></tr></table></figure></p>
<p>即<code>fn3</code>作为源函数，被<code>_fn2</code>和<code>_fn1</code>装饰了</p>
<h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h3><p><code>Redux</code>官方文档中<code>middleware</code>的使用方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let createStoreWithMiddleware = applyMiddleware()(createStore)</div></pre></td></tr></table></figure></p>
<p>当然，由于<code>applyMiddleware</code>函数的一些特性，使用的方法不止这一种，本文只以这种使用方法为例</p>
<p>接下来，我们就来一步一步来看看这样使用时发生了什么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function applyMiddleware(...middlewares) &#123;</div><div class="line">    return (next) =&gt; (reducer, initialState) =&gt; &#123;</div><div class="line">        var store = next(reducer, initialState); // 这里的 next 为原先的 createStore，调用next相当于创建了一个新的store</div><div class="line">        var dispatch = store.dispatch;</div><div class="line">        var chain = [];</div><div class="line"></div><div class="line">        var middlewareAPI = &#123;</div><div class="line">            getState: store.getState,</div><div class="line">            dispatch: (action) =&gt; dispatch(action)</div><div class="line">        &#125;;</div><div class="line">        chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)); // 将传进来的middleware运行，并将返回的结果映射到chain数组中</div><div class="line">        dispatch = compose(...chain)(store.dispatch); // 相当于将store.dispatch作为源函数，用chain中的每一个函数去装饰它</div><div class="line"></div><div class="line">        return Object.assign(&#123;&#125;,store,&#123;dispatch&#125;);</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>了解原理后，再来看<code>middleware</code>的写法就不会觉得那么奇怪了。下面是一般情况下<code>middleware</code>函数的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function middleware(&#123;dispatch,getState&#125;)&#123; // 这里的&#123;dispatch,getState&#125;是chain赋值的时候传递的参数</div><div class="line">    return function (next) &#123; // next是compose中传递的参数</div><div class="line">        return function (action) &#123; // action是dispatch传递的参数，如果存在其他中间件，action也可能被修改</div><div class="line">            ...</div><div class="line">            return next();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上就是<code>redux</code>中<code>middleware</code>得实现原理即使用方法</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/25/node-中的一些坑/" itemprop="url">
                  node 中的一些坑
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-25T21:01:27+08:00" content="2016-09-25">
              2016-09-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文会持续更新……</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p><code>node</code>中通过<code>require</code>引入模块的机制为将需要的模块对应的<code>js</code>文件引入后执行一遍，因此在自己写的依赖模块中尽量不要无故输出信息，否则会使控制台十分混乱。</p>
<h3 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h3><p><code>fs</code>模块中的所有方法在指定路径时都必须为绝对路径或是完整的相对路径（即包含<code>../</code>、<code>./</code>、<code>/</code>的相对路径）。</p>
<h4 id="fs-mkdir-mkdirSync"><a href="#fs-mkdir-mkdirSync" class="headerlink" title="fs.mkdir/mkdirSync"></a>fs.mkdir/mkdirSync</h4><p>API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(path, callback)</div></pre></td></tr></table></figure></p>
<p>创建文件夹操作，支持文件夹嵌套，例如<code>fs.mkdir(&#39;./a/b/c&#39;)</code>,回调函数中的参数为<code>Error</code>信息，只有发生错误的时候才会存在，创建成功则为<code>null</code>。</p>
<p><code>mkdir</code>操作的路径如果有文件夹嵌套，则当上级路径不存在时，不能直接创建。例如当前文件夹下没有<code>a</code>文件夹，则<code>fs.mkdir(&#39;./a/b&#39;)</code>不能直接创建<code>a</code>和<code>a/b</code>文件夹。</p>
<p>为了减少代码的重复量，可使用下面的函数来对<code>mkdir</code>操作进行封装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">let path = require(&apos;path&apos;),</div><div class="line">    fs = require(&apos;fs&apos;);</div><div class="line">function mkdir(p,fn)&#123;</div><div class="line">    fs.exists(p, function (flag) &#123; // 判断当前路径下的文件夹是否已经存在</div><div class="line">        if(flag)&#123; // 如果当前文件夹已经存在则执行回调函数</div><div class="line">            return fn();</div><div class="line">        &#125;</div><div class="line">        // 如果当前文件夹不存在，则将当前文件夹的上级目录作为新的参数p，创建当前文件夹的操作放入回调函数，递归调用mkdir函数</div><div class="line">        mkdir(path.dirname(p), function () &#123;</div><div class="line">            fs.mkdir(p,fn);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里用到了<code>path</code>模块的<code>dirname</code>方法，这个方法的作用是获取一个路径的上级路径。</p>
<h4 id="fs-readFile-readFileSync"><a href="#fs-readFile-readFileSync" class="headerlink" title="fs.readFile/readFileSync"></a>fs.readFile/readFileSync</h4><p>读取文件操作，在使用同步方法<code>readFileSync</code>时函数直接返回读到的数据，如果发生错误则返回错误的信息。</p>
<p>但是异步方法<code>readFile</code>在<code>callback</code>中的参数却是<code>error</code>和<code>data</code>，即不管是否成功第一个参数都是<code>error</code>，第二个参数才是读到的数据。</p>
<p>在<code>node</code>中应尽量用<code>stream</code>来代替文件的直接读写操作。</p>
<h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><h3 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h3><h4 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h4><p>如果需要采用<code>cors</code>来支持跨域请求，则需要对请求头进行如下设置（完整版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">res.writeHead(200, &#123;</div><div class="line">    &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,</div><div class="line">    &quot;Access-Control-Allow-Methods&quot;: &quot;GET, POST, PUT, DELETE, OPTIONS&quot;,</div><div class="line">    &quot;Access-Control-Allow-Headers&quot;: &quot;Content-Type, accept&quot;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>另外，跨域时尽量对请求方法和请求路径都进行验证（RESTful），因为某些客户端框架（ionic）在发送跨域请求时，会先发送一个<code>option</code>方法的请求来尝试跨域请求是否成功，在成功之后才会发送原本的请求。</p>
<h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>一般在<code>node</code>中设置<code>cookies</code>都会使用基于<code>express</code>的第三方包<code>cookie-parser</code>。不使用第三方包的原生写法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res.setHeader(&quot;Set-Cookie&quot;, [...cookies])</div></pre></td></tr></table></figure></p>
<p>其中<code>cookies</code>的格式为<code>key=value; option</code>，注意<code>;</code>后的空格。</p>
<p><code>option</code>的参数中<code>max-age=time</code>表示<code>cookie</code>的过期时间，其中<code>time</code>的为<code>number</code>，单位是秒。</p>
<p>获取客户端传递的<code>cookies</code>的方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.headers.cookie</div></pre></td></tr></table></figure></p>
<p>如果使用<code>express</code>和<code>cookie-parser</code>，则关于<code>cookie</code>的方法都会被集成在<code>request</code>和<code>response</code>上，设置<code>cookie</code>的方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res.cookie(key, value, option)</div></pre></td></tr></table></figure></p>
<p>注意这里的<code>option</code>中的<code>max-age</code>单位变为了毫秒，其他则没有变化。</p>
<p>获取客户端传递的<code>cookies</code>的方法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">req.cookies</div></pre></td></tr></table></figure></p>
<p>获取的<code>cookies</code>为对象形式。</p>
<p>IDE没有提示功能或者提示功能不全的朋友请注意上文中的<code>cookie</code>和<code>cookies</code>并背诵熟练 :)。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/18/Angular依赖注入原理/" itemprop="url">
                  Angular 依赖注入原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-18T19:26:39+08:00" content="2016-09-18">
              2016-09-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>依赖注入的机制是Angular管理代码依赖关系的重要手段。</p>
<p>一般来说，一个函数要想获取它的依赖，有三种方式：</p>
<ol>
<li>在函数内部通过new来创建依赖；</li>
<li>通过全局变量查找依赖；</li>
<li>在依赖被需要时导入；</li>
</ol>
<p>很显然，前两种方式都有一定程度的不足之处，他们都需要将依赖提前编码，使得对依赖进行动态修改变得相当麻烦。而第三种方式无疑是我们理想的方式。</p>
<p>Angular中实现依赖注入的方法很简单，就是在每个模块上使用一个数组<code>providers</code>将创建服务的构造函数保存，同时在<code>injector</code>上用一个数组<code>providerCache</code>将实例化后的服务缓存，调用服务时先检查是否有缓存，以此来保证服务为单例模式。</p>
<h2 id="Angular中的依赖注入"><a href="#Angular中的依赖注入" class="headerlink" title="Angular中的依赖注入"></a>Angular中的依赖注入</h2><p>Angular中使用注射器来实现依赖注入，在Angular中，直接通过<code>angular.injector()</code>便可获得一个<code>injector</code>实例，将其打印可以发现<code>injector</code>带有5个方法：</p>
<ul>
<li>annotate</li>
<li>get</li>
<li>has</li>
<li>instantiate</li>
<li>invoke</li>
</ul>
<p>下面我们来一一讲解这些方法的作用：</p>
<ol>
<li><code>annotate</code>的参数为一个函数，<code>annotate</code>不会运行这个函数，只会将这个函数中的参数名集成为一个数组并返回。这个方法主要用来对函数进行预解析，获取函数内部需要的服务名称。</li>
<li><code>get</code>的参数为一个服务名，返回一个服务实例。</li>
<li><code>has</code>查看某个服务的构造函数是否存在。</li>
<li><code>invoke</code>注入服务，它是对上面三个函数的封装。</li>
<li><code>instantiate</code>将一个服务实例化。主要在<code>factory</code>定义服务时使用。</li>
</ol>
<p>为了更好的理解这些方法，我们一边模拟这些方法一边讲解其原理。</p>
<h2 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h2><p>我们先模拟一个provider来创建服务，服务和<code>injector</code>都是基于模块的，因此需要一个模块构造函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Module()&#123;&#125;</div><div class="line"></div><div class="line">Module.providers = []; // 存储服务构造函数</div><div class="line">Module.providerCache = []; // 缓存服务实例</div><div class="line"></div><div class="line">Module.provider = function (serviceName, service) &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Module.injector = function () &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在此基础上模拟provider<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Module.prototype.provider = function (serviceName, constructor) &#123;</div><div class="line">    this.providers[serviceName] = constructor; // 每次创建服务都将构造函数保存在providers中</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="annotate"><a href="#annotate" class="headerlink" title="annotate"></a>annotate</h2><p>其原理为将传入的函数转换为字符串后通过正则来解析，为简便，本文只考虑通过<code>function</code>定义的匿名函数的情况，模拟代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">injector.annotate = (fn)=&gt; &#123;</div><div class="line">    return  fn.toString().match(/function\s+\((.*)\)/)[1].replace(/\s+/g,&apos;&apos;).split(&apos;,&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="has"><a href="#has" class="headerlink" title="has"></a>has</h2><p><code>has</code>用来查询服务的构造函数是否存在，再服务实例化时需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">injector.has = (serviceName)=&gt; &#123;</div><div class="line">    return this.providers[serviceName] ? true : false</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p><code>get</code>会先遍历注射器的<code>providerCache</code>，如果没有这一服务的实例化则尝试将其创建。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">injector.get = (serviceName)=&gt; &#123;</div><div class="line">    let service = this.providerCache[serviceName];</div><div class="line">    if (!service) &#123; //如果没有这个服务，尝试创建这个服务</div><div class="line">        if (!injector.has(serviceName)) &#123;</div><div class="line">            throw new Error(&quot;No such service &quot; + serviceName);</div><div class="line">        &#125;</div><div class="line">        let instant = new this.providers[serviceName];</div><div class="line">        service = instant.$get();</div><div class="line">        this.providerCache[serviceName] = service;</div><div class="line">    &#125;</div><div class="line">    return service;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><p><code>invoke</code>先调用<code>annotate</code>来检测需要的服务的名称，然后用<code>get</code>方法一次获取服务，最后执行函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">injector.invoke = function (fn, thisObj) &#123;</div><div class="line">    let args = injector.annotate(fn), // 获取需要的服务名称</div><div class="line">        arr = []; // 用来存放所有的服务实例</div><div class="line">    if (args[0] != &apos;&apos;) &#123;</div><div class="line">        for (var i = 0; i &lt; args.length; i++) &#123;</div><div class="line">            arr.push(this.get(args[i]));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    fn.apply(thisObj, arr);// 调用这个函数，将函数中this改为invoke传入的参数thisObj，并把服务实例依次传入</div><div class="line">    return thisObj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Angular中需要依赖注入的函数都会自动执行invoke，这就是Angular依赖注入的原理。</p>
<p>最后我们验证一下这些模拟的代码是否实现了期望的功能。引入以上代码后写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Module.provider(&quot;myService&quot;, function () &#123;</div><div class="line">    this.$get = function () &#123;</div><div class="line">        console.log(&quot;Create service&quot;); // 不管注入几次，服务只会实例化一次，因此&quot;Create service&quot;只会输出一次</div><div class="line">        return &#123;</div><div class="line">            name: &quot;yyh&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">let myModule = new Module();</div><div class="line"></div><div class="line">Module.injector().invoke(function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出&quot;yyh&quot;</div><div class="line">    myService.address = &quot;北京&quot;;</div><div class="line">&#125;, myModule);</div><div class="line"></div><div class="line">Module.injector().invoke(function (myService) &#123;</div><div class="line">    console.log(myService.address); // 输出&quot;北京&quot;</div><div class="line">&#125;,myModule);</div></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Create service</div><div class="line">yyh</div><div class="line">北京</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/15/Angular中的自定义服务/" itemprop="url">
                  Angular 自定义服务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-15T15:18:38+08:00" content="2016-09-15">
              2016-09-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>Angular services are singletons objects or functions that carry out specific tasks common to web apps.</p>
</blockquote>
<p>这是Angular中对服务的定义，它是一个单例对象或函数，为web app提供特定的功能。</p>
<p>Angular中提供的服务都是以“$”开头，通过Angular的依赖注入机制可将服务注入控制器中。除此以外，我们还可以通过Angular提供的API来自定义服务。</p>
<h2 id="自定义服务"><a href="#自定义服务" class="headerlink" title="自定义服务"></a>自定义服务</h2><p>Angular中提供的用于定义服务的服务为<code>$provide</code>（即<code>$provide</code>本身也是一个服务），<code>$provide</code>上有6个方法</p>
<ul>
<li>provider</li>
<li>factory</li>
<li>service</li>
<li>value</li>
<li>constant</li>
<li>decorator</li>
</ul>
<p>前五个用来定义服务，最后一个用来装饰服务。</p>
<h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">provider(serviceName, constructor)</div></pre></td></tr></table></figure>
<p><code>provider</code>可以接收两个参数<code>serviceName</code>和<code>constructor_</code>，顾名思义，<code>serviceName</code>就是自定义服务的名称，<code>constructor</code>则是Angular中服务的构造函数。<code>provider</code>的用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">let app = angular.module(&quot;appModule&quot;, []);</div><div class="line"></div><div class="line">app.config(function ($provide) &#123;</div><div class="line">    $provide.provider(&quot;myService&quot;, function () &#123;</div><div class="line">        this.$get = function () &#123;</div><div class="line">            return&#123;</div><div class="line">                name: &quot;yyh&quot;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;first&quot;, function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出yyh</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>在Angular的依赖注入机制中会用<code>invoke</code>将<code>provider_</code>实例化，在控制器中实际获取的服务为<code>provider_</code>中<code>$get</code>返回的内容。</p>
<p>Angular为$provide的6个方法提供了简便的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.provider(&quot;myService&quot;, function () &#123;</div><div class="line">    this.$get = function () &#123;</div><div class="line">        return &#123;</div><div class="line">            name: yyh</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>效果与在<code>config</code>中定义服务相同，其他方法同理，下文将使用这种简便写法。</p>
<h4 id="配置provider"><a href="#配置provider" class="headerlink" title="配置provider"></a>配置provider</h4><p>Angular提供的服务是可配置的，但只有通过<code>provider</code>方式设置的服务才能实现配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let app = angular.module(&quot;appModule&quot;, []);</div><div class="line"></div><div class="line">app.provider(&quot;myService&quot;, function () &#123;</div><div class="line">    this.name = &quot;yyh&quot;;</div><div class="line">    this.$get = function () &#123;</div><div class="line">        return &#123;</div><div class="line">            name: this.name // 此时name为yyh</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">// 配置myService中的name，注意在myService后添加Provider</div><div class="line">app.config(function (myServiceProvider) &#123;</div><div class="line">    myServiceProvider.name = &quot;yyh1&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;first&quot;, function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出yyh1</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="factory"><a href="#factory" class="headerlink" title="factory"></a>factory</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">factory(serviceName, factoryFn, enforce)</div></pre></td></tr></table></figure>
<p><code>factory</code>可以接受三个参数，<code>serviceName</code>为服务名，<code>enforce</code>为强制返回值，一般不使用。<code>factory</code>的用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let app = angular.module(&quot;appModule&quot;, []);</div><div class="line"></div><div class="line">app.factory(&quot;myService&quot;, function () &#123;</div><div class="line">    return&#123;</div><div class="line">        name: &quot;yyh&quot;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;first&quot;, function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出 yyh</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><code>factory</code>中省去了为<code>$get</code>赋值的过程，其实在<code>factory</code>内部进行了类似的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function factory(serviceName, factoryFn)&#123;</div><div class="line">    return provider(serviceName, &#123;</div><div class="line">        $get: factoryFn</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即<code>factory</code>为<code>provider</code>的封装。</p>
<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service(serviceName, constructor)</div></pre></td></tr></table></figure>
<p><code>service</code>可以接受两个参数，其用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let app = angular.module(&quot;appModule&quot;, []);</div><div class="line"></div><div class="line">app.service(&quot;myService&quot;, function () &#123;</div><div class="line">    this.name = &quot;yyh&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;first&quot;, function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出 yyh</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即在<code>constructor</code>中直接通过<code>this</code>来设置服务的内容，相比<code>factory</code>又更简洁了一些，其实其内部调用了<code>factory</code>，通过一个名为<code>instantiate</code>的函数将<code>constructor</code>的内容实例化后传入到<code>factory</code>中。其内部原理类似于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function service(servicName, constructor)&#123;</div><div class="line">    return factory(serviceName, function()&#123;</div><div class="line">        return instantiate(constructor) // 将constructor实例化</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">value(serviceName, val)</div></pre></td></tr></table></figure>
<p><code>value</code>接受两个参数，服务名和服务内容。其使用方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let app = angular.module(&quot;appModule&quot;, []);</div><div class="line"></div><div class="line">app.value(&quot;myService&quot;, &#123;</div><div class="line">    name: &quot;yyh&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;first&quot;, function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出 yyh</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即<code>val</code>的内容就是服务的内容，这种写法最为简洁，原理也很简单。</p>
<p><code>value</code>的内部同样调用了<code>factory</code>，其内部进行的操作类似于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function value(serviceName, val)&#123;</div><div class="line">    return factory(serviceName, function()&#123;</div><div class="line">        return val;</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：以上对于value、service、factory原理解释的代码并非Angular源码，只是作者为便于说明而添加的。</p>
<h3 id="constant"><a href="#constant" class="headerlink" title="constant"></a>constant</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constant(name, value)</div></pre></td></tr></table></figure>
<p><code>constant</code>的使用方法和<code>value</code>类似，这里附上其源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function constant(name, value) &#123;</div><div class="line">    assertNotHasOwnProperty(name, &apos;constant&apos;);</div><div class="line">    providerCache[name] = value; // 服务缓存，所有服务都是从这里获取</div><div class="line">    instanceCache[name] = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码中的注释为本文作者添加。</p>
<p>可以看到，<code>constant</code>直接将<code>value</code>中的内容放入到服务缓存中，这种做法导致的后果就是<code>constant</code>中的内容不可被修改。<code>constant</code>也是定义服务的方法中唯一没有调用<code>provider</code>的。</p>
<h3 id="decorator"><a href="#decorator" class="headerlink" title="decorator"></a>decorator</h3><p>翻译为中文就是修饰，用于动态的扩展服务，扩展的服务只在当前模块内起作用，而不会影响到其他模块。<code>decorator</code>的用法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">let app = angular.module(&quot;appModule&quot;, []);</div><div class="line"></div><div class="line">app.value(&quot;myService&quot;, &#123;</div><div class="line">    name: &quot;yyh&quot;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.config(function ($provide) &#123;</div><div class="line">    $provide.decorator(&quot;myService&quot;, function ($delegate) &#123;</div><div class="line">        // $delegate为原服务</div><div class="line">        $delegate.age = &quot;20&quot;;</div><div class="line">        return $delegate; // 返回装饰后的服务</div><div class="line">    &#125;)</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.controller(&quot;first&quot;, function (myService) &#123;</div><div class="line">    console.log(myService.name); // 输出 yyh</div><div class="line">    console.log(myService.age); // 输出 20</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/10/Angular数据双向绑定原理/" itemprop="url">
                  Angular 数据双向绑定原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-10T21:05:06+08:00" content="2016-09-10">
              2016-09-10
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>作为一个MVVM框架，数据双向绑定可以说是Angular最核心的功能之一，本文就以JavaScript语言来讲解其背后的原理。</p>
<p>在Angular中添加这样一段html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">    &lt;input type=&quot;text&quot; ng-model=&quot;input&quot;&gt;</div><div class="line">    &#123;&#123;input&#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>此时input输入框的后面便会实时显示用户输入的内容，那么它是怎样实现的呢？要明白这背后的原理，就需要先学习两个函数$scope.$watch和$scope.$apply。</p>
<h2 id="scope-watch"><a href="#scope-watch" class="headerlink" title="$scope.$watch"></a>$scope.$watch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$scope.$watch(exp, listener, objectEquality)</div></pre></td></tr></table></figure>
<p>$scope.$watch用于监听一个当前作用域变量的变化，第一个参数监听变量的表达式（exp），第二个参数为变量变化时的回调函数（listener），第三个参数表示监听的是一个变量还是对象。当监听的是一个变量时，可以忽略第三个参数。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$scope.name = &quot;yyh&quot;;</div><div class="line"></div><div class="line">$scope.$watch(&quot;name&quot;, function (newValue, oldValue) &#123;</div><div class="line">    console.log(&quot;$scope.name was changed&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>listener中的newValue为当前变量的最新值，oldValue则为更改前的值。</p>
<p>其中第一个参数也能以函数的形式传递，只要在函数中返回需要监听的变量即可，如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$scope.$watch( function()&#123;</div><div class="line">    return $scope.name;</div><div class="line">&#125;, function (newValue, oldValue) &#123;</div><div class="line">    console.log(&quot;$scope.name was changed&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这种写法的效率较高，因为如果第一个参数为字符串，Angular也会将其替换为函数。</p>
<p>在Angular的$scope中创建变量时，Angular会自动执行$watch来监听这一变量。</p>
<p>调用$scope.$watch后，Angular会将当前变量注册到监听列表$scope.$$watchers中。</p>
<h3 id="scope-watchers"><a href="#scope-watchers" class="headerlink" title="$scope.$$watchers"></a>$scope.$$watchers</h3><p>$scope中的$$watchers数组保存着当前注册监听的变量，其结构为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$$watchers = [</div><div class="line">    &#123;</div><div class="line">        eq: false, // 表明监听的变量是否为一个对象</div><div class="line">        fn: function( newValue, oldValue ) &#123;&#125;, // 监听函数(listener)</div><div class="line">        last: &apos;yyh&apos;, // 变量最新值</div><div class="line">        exp: function()&#123;&#125;, // 监听变量的表达式函数(exp)</div><div class="line">        get: function()&#123;&#125; // Angular编译后的exp函数</div><div class="line">    &#125;</div><div class="line">];</div></pre></td></tr></table></figure></p>
<h2 id="scope-apply"><a href="#scope-apply" class="headerlink" title="$scope.$apply"></a>$scope.$apply</h2><p>在讲解$scope.$apply之前，需要先了解$rootScope.$digest</p>
<h3 id="rootScope-digest"><a href="#rootScope-digest" class="headerlink" title="$rootScope.$digest"></a>$rootScope.$digest</h3><p>$rootScope.$digest即脏值检查函数，它会遍历所有$scope中的$$watchers数组，将每一个watcher（$$watchers的每一项）的last属性与当前变量的最新值进行比较，如果在任意一个watcher中发现两者不相等（检查结果为dirty），则执行watcher中的fn函数，并在脏值检查完毕后刷新视图。</p>
<p>为了防止watcher的fn函数中再次更改变量，如果检测到有值发生了改变，则脏值检查会再执行一次。</p>
<p>同时为了防止watcher的fn函数中无限次更改变量，脏值检查最多只会执行十次，且如果此时执行结果仍为dirty，则throw一个error。</p>
<h3 id="scope-apply-1"><a href="#scope-apply-1" class="headerlink" title="$scope.$apply"></a>$scope.$apply</h3><p>$scope.$apply的作用为刷新视图，$scope.$apply可以传一个函数作为其参数，$scope.$apply会先执行这个函数，然后再去执行$rootScope.$digest。</p>
<p>Angular的指令、控制器等运行时都会在结尾时执行$scope.$apply，而JavaScript原生的函数则没有这一功能，如setTimeout、setInterval等，例如在JavaScript中写入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">app.controller(&quot;first&quot;, function ($scope) &#123;</div><div class="line">    $scope.name = &quot;yyh&quot;;</div><div class="line">    window.setTimeout(function () &#123;</div><div class="line">        $scope.name = &quot;yyh1&quot;;</div><div class="line">        console.log($scope.$$watchers[0])</div><div class="line">    &#125;,2000)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在html中写入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div ng-controller=&quot;first&quot;&gt;</div><div class="line">    &#123;&#123;name&#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>可以看到，2秒后视图并没有发生变化，此时控制台输出的watcher中的last也没有更新，此时如果将JavaScript代码 更改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">app.controller(&quot;first&quot;, function ($scope) &#123;</div><div class="line">    $scope.name = &quot;yyh&quot;;</div><div class="line">    window.setTimeout(function () &#123;</div><div class="line">        $scope.name = &quot;yyh1&quot;;</div><div class="line">        console.log($scope.$$watchers[0]);</div><div class="line">        $scope.$apply();// 执行$apply</div><div class="line">    &#125;,2000)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>则2秒后视图便会发生变化，这就是模型绑定视图的原理。</p>
<p>同时，为了能够实现模型绑定视图，Angular为以下事件都绑定了$scope$apply方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste</div></pre></td></tr></table></figure></p>
<p>即用户触发以上事件时，Angular自动执行$scope$apply，这就实现了视图绑定模型。</p>
<h2 id="模拟双向数据绑定"><a href="#模拟双向数据绑定" class="headerlink" title="模拟双向数据绑定"></a>模拟双向数据绑定</h2><p>为了更深入地理解Angular的双向数据绑定的原理，我们用原生JavaScript来自己实现一个简版的数据双向绑定。</p>
<p>首先是scope的构造函数，每个scope都有自己私有的$$watchers和公有的$watch、$apply、$digest方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Scope()&#123;</div><div class="line">    this.$$watchers = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Scope.prototype.$watch = function () &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Scope.prototype.$apply = function () &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Scope.prototype.$digest = function () &#123;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后分别实现这三个方法</p>
<h3 id="模拟-watch"><a href="#模拟-watch" class="headerlink" title="模拟$watch"></a>模拟$watch</h3><p>$watch的作用为注册监听变量，即将参数封装为一个对象后push到$$watchers中，本文为了简便只为watcher添加fn、exp、last属性，且默认exp为函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$watch = function (exp, listener) &#123;</div><div class="line">    let watcher = &#123;</div><div class="line">        exp: exp,</div><div class="line">        fn: listener,</div><div class="line">        last: exp() // 获取变量最新值</div><div class="line">    &#125;;</div><div class="line">    this.$$watchers.push(watcher);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="模拟-digest"><a href="#模拟-digest" class="headerlink" title="模拟$digest"></a>模拟$digest</h3><p>$digest为脏值检查，首先将单次脏值检查的过程封装在$digestOne中，其返回值dirty为true则表示变量发生了改变</p>
<p>$digestOne<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digestOne = function () &#123;</div><div class="line">    let dirty = false;</div><div class="line">    this.$$watchers.forEach(function (watcher) &#123; // 遍历所有watcher</div><div class="line">        let newValue = watcher.exp(),</div><div class="line">            oldValue = watcher.last;</div><div class="line">        if (newValue !== oldValue) &#123; // 如果监听到值发生改变，则将dirty置为true，更新last，并执行回调函数</div><div class="line">            watcher.last = newValue;</div><div class="line">            watcher.fn(newValue, oldValue);</div><div class="line">            dirty = true;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return dirty;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>然后在$digest中调用$digestOne，并计算执行次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$digest = function () &#123;</div><div class="line">    let dirty = false,</div><div class="line">        count = 10;</div><div class="line">    do &#123; // 执行$digestOne，如果dirty为true则再次检查，但是最多不超过10次</div><div class="line">        dirty = this.$digestOne();</div><div class="line">    &#125; while (dirty &amp;&amp; --count);</div><div class="line">    if(dirty &amp;&amp; count == 0)&#123; // 如果执行十次$digestOne后，dirty仍然为true，则报错</div><div class="line">        throw new Error(&apos;10 $digest() iterations reached. Aborting!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="模拟-apply"><a href="#模拟-apply" class="headerlink" title="模拟$apply"></a>模拟$apply</h3><p>$apply负责执行传递的函数和调用$digest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Scope.prototype.$apply = function (fn) &#123;</div><div class="line">    if(typeof fn == &quot;function&quot;)&#123;</div><div class="line">        fn();</div><div class="line">    &#125;</div><div class="line">    this.$digest();</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这样，（简易的）数据绑定工具便制作完成了，接下来我们就用这些工具来写一个双向绑定的demo。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>在html中添加一个input标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;text&quot; id=&quot;name&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>，引入之前创建的工具，在JavaScript代码中写入如下内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let scope = new Scope(),</div><div class="line">    input = document.querySelector(&quot;#name&quot;);</div><div class="line"></div><div class="line">scope.$watch(function () &#123; // 在创建变量之前，先为变量绑定$watch监听</div><div class="line">    return scope.name;</div><div class="line">&#125;, function (newValue,oldValue) &#123; // 变量发生改变后将其重新绑定到视图</div><div class="line">    input.value = newValue;</div><div class="line">    console.log(scope.name);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">window.setTimeout(function () &#123;</div><div class="line">    scope.name = &quot;yyh&quot;;</div><div class="line">    scope.$apply(); // 程序中改变变量后执行$apply</div><div class="line">&#125;,2000);</div><div class="line"></div><div class="line"></div><div class="line">input.addEventListener(&quot;keyup&quot;, function () &#123; // 视图发生改变，则执行$apply</div><div class="line">    scope.name = this.value;</div><div class="line">    scope.$apply();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样，一个（简版的）双向数据绑定demo就完成了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/JavaScript中继承的实现/" itemprop="url">
                  JavaScript 中继承的实现方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-05T21:01:27+08:00" content="2016-09-05">
              2016-09-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>JavaScript</code>中没有类的概念，所有类的概念都是来源于<code>prototype</code>，因此在实现类的继承的方法上，各路程序员各显神通，总结出了一个又一个的方法。当然，如果你使用的是<code>ES6</code>，可以直接跳到最后一页。</p>
<p>本文将总结过去被用来实现继承的方法，分析他们的优缺点以及适用环境。本文适合对原型、构造函数有一定了解的读者。</p>
<p>首先准备原料：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Parent(name,age)&#123; // 父类</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.address = &apos;Peking&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Parent.prototype.sayName = function () &#123;</div><div class="line">    console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function Child(name, age)&#123;&#125; // 子类</div><div class="line"></div><div class="line">Child.prototype.sayAge = function () &#123;</div><div class="line">    console.log(this.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>父类三个私有属性<code>name</code>、<code>age</code>、<code>address</code>，其中<code>address</code>属性不是根据构造函数传递的参数来决定的，同时父类还有一个公有方法<code>sayName</code>，子类也有一个公有方法<code>sayAge</code>。</p>
<h2 id="call-apply继承"><a href="#call-apply继承" class="headerlink" title="call/apply继承"></a>call/apply继承</h2><p>这种方法也叫作构造函数绑定，具体实现方法就是在子类的构造函数中通过<code>call/apply</code>调用父类构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Child(name, age) &#123;</div><div class="line">    Parent.apply(this, arguments);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，这种继承方式只是将父类的私有属性继承为了子类的私有属性，是最简单的继承方法。</p>
<p>但是很多时候，我们还需要继承父类原型上的属性，同时，这种继承方法让我们无法获知子类继承自哪一父类，尤其是当子类继承了多个父类时。因此，这一方法更多的还是同其他继承方法混合使用。</p>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>为子类构造函数的<code>prototype</code>重新赋值为父类的一个实例，实现方法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Child.prototype = new Parent();</div></pre></td></tr></table></figure></p>
<p>这种方法可以将父类的公有属性和私有属性都继承为子类的公有属性，比较符合我们队原型链的认知。此处没有为<code>Parent</code>构造函数传递参数，也可以选择传递。</p>
<p>值得注意的是，这种方法会覆盖子类原有的<code>prototype</code>，所以我们需要对原型链进行一些维护，具体到本问题，则需要做如下处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Child.prototype.sayAge = function () &#123; // 子类原有的公有方法会被覆盖，应在继承后声明</div><div class="line">    console.log(this.age);</div><div class="line">&#125;;</div><div class="line">Child.prototypr.constructor = Child; // 将丢失的constructor属性补全</div></pre></td></tr></table></figure></p>
<p>另外，如果在为<code>Child.prototype</code>赋值的时候不为<code>Parent</code>构造函数传递参数，则<code>name</code>、<code>age</code>属性虽然会被赋值一次，但是值仍然为<code>undefined</code>，相当于没有继承，而<code>address</code>属性却会被强制继承，这样既浪费性能，也不便于我们管理。</p>
<h2 id="prototype直接继承"><a href="#prototype直接继承" class="headerlink" title="prototype直接继承"></a>prototype直接继承</h2><p>有时候，我们不需要继承父类的私有属性，此时便可以直接将子类的<code>prototype</code>赋值为父类的<code>prototytpe</code>，具体做法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Child.prototype = Parent.prototype;</div></pre></td></tr></table></figure></p>
<p>但是，这种方法也需要对原型链进行维护，但此时问题就来了，因为<code>Child.prototype</code>与<code>Parent.prototype</code>指向的是同一个对象，因此修改<code>Child.prototype.constructor = Child</code>的同时也会将<code>Parent.prototype。constructor</code>修改为<code>Child</code>，这显然不是我们希望的。所有我们有了第四种方法。</p>
<h2 id="中间件继承"><a href="#中间件继承" class="headerlink" title="中间件继承"></a>中间件继承</h2><p>因为<code>prototype</code>直接继承方法的缺陷，我们想到，可以让子类的原型先等于一个空构对象，再让这个空对象的原型等于父类的原型，就可以避免这一缺陷。实现方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let Fn = function()&#123;&#125;;</div><div class="line">Fn.prototype = Parent.prototype;</div><div class="line">Child.prototype = new Fn();</div><div class="line">Child.constructor = Child;</div></pre></td></tr></table></figure></p>
<p>这样就可以避免对子类原型的修改涉及父类。</p>
<p>熟悉原型链的读者想必已经想到了更简单的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Child.prototype.__proto__ = Parent.prototype;</div></pre></td></tr></table></figure></p>
<p>因为子类原型的<code>__proto__</code>属性本来就是一个对象，所以直接对其赋值便可以实现中间件继承。这种写法不会修改类的原型，个人认为是中间件继承的最优写法（如果修改<code>__proto__</code>这一行为不被禁止的话）。</p>
<h2 id="Object-create继承"><a href="#Object-create继承" class="headerlink" title="Object.create继承"></a>Object.create继承</h2><p>这种方法最先的实现方式是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function object(class)&#123;</div><div class="line">    function Fn()&#123;&#125;</div><div class="line">    Fn.prototype = class;</div><div class="line">    return new Fn();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方法抛弃了构造函数，<code>object()</code>不是构造函数，却直接返回了一个新的对象，这个对象可以看作是我们需要的子类实例。</p>
<p>和中间件继承相比，就会发现他们一些相似的地方，因此这一函数也可以用来实现中间件继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Child.prototype = object(Parent.prototype);</div></pre></td></tr></table></figure></p>
<p>后来这一方法被<code>ES5</code>纳入了官方文档，通过<code>Object.create()</code>来使用。</p>
<h2 id="拷贝继承"><a href="#拷贝继承" class="headerlink" title="拷贝继承"></a>拷贝继承</h2><p>抛弃构造函数实现继承的方法还有一种，就是拷贝继承，即将父对象的属性全部拷贝给子对象，以此来实现继承：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function copy(parent)&#123;</div><div class="line">    let child = &#123;&#125;;</div><div class="line">    for(let key in parent)&#123; // 将父对象的属性拷贝给子对象</div><div class="line">        child[key] = parent[key];</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但这种方法有一个问题，就是如果父对象的某一属性为<code>Array</code>、<code>Object</code>引用数据类型时，便无法实现真正的拷贝，只是传递了这些数据的引用而已。</p>
<p>解决这一问题的方法当然是使用递归：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function copy(parent) &#123;</div><div class="line">    let child = &#123;&#125;;</div><div class="line">    for (let key in parent) &#123;</div><div class="line">        let curProp = parent[key];</div><div class="line">        if (curProp &amp;&amp; typeof curProp == &apos;object&apos;) &#123; // 如果属性为对象或数组且不为空则递归调用copy方法</div><div class="line">            child[key] = copy(curProp);</div><div class="line">        &#125; else &#123;</div><div class="line">            child[key] = curProp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种继承方法的好处是比较自由，如果配合<code>hasOwnProperty</code>或别的条件来设置判断的话，可以实现自定义的继承，也就是说只要你愿意，可以父对象将任意的属性继承为子对象私有或公有属性。</p>
<p>即使不使用其他判断条件，这种方法还是有很多好处，例如彻底隔绝子对象和父对象的关系，不管怎么修改子对象的原型链，父对象都不会受影响。</p>
<p>这种继承方法也是目前<code>jQuery</code>中使用的继承方法。</p>
<h2 id="混合继承"><a href="#混合继承" class="headerlink" title="混合继承"></a>混合继承</h2><p>混合继承就是将上述几种方法中的两种或多种混合使用。</p>
<p>上述的几种继承方式中，<code>call/apply</code>继承可以将父类的私有属性继承为子类的私有属性，中间件继承可以将父类的公有属性继承为子类的公有属性，且不会破坏原型链，因此这两种方法最常在混合继承中同时使用。</p>
<h2 id="node中的继承"><a href="#node中的继承" class="headerlink" title="node中的继承"></a>node中的继承</h2><p>在<code>node</code>中同样可以使用上述其他方法，不过<code>node</code>的内置模块<code>util</code>提供了一个继承方法供我们直接使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let util = require(&apos;util&apos;);</div><div class="line">util.inherits(Child,Parent);</div></pre></td></tr></table></figure></p>
<p>这个方法的效果其实和中间件继承相同。</p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p><code>ES6</code>提供的<code>class</code>和<code>extends</code>语法使得<code>JavaScript</code>（在语法上）第一次有了类的概念，它们的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">    constructor(name, age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getName() &#123;</div><div class="line">        console.log(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Child extends Parent &#123;</div><div class="line">    constructor(name, age) &#123;</div><div class="line">        super(name, age);</div><div class="line">    &#125;</div><div class="line">    getAge()&#123;</div><div class="line">        console.log(this.age);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>constructor</code>其实就是构造函数，<code>constructor</code>的外部就是原型上的方法。如果想添加静态方法，可以在<code>constructor</code>的外部使用<code>static</code>关键字来添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">    constructor(name, age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static sayHello()&#123;</div><div class="line">        console.log(&apos;hello&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Parent.sayHello();// 输出“hello”</div></pre></td></tr></table></figure></p>
<p>值得一提的是，目前<code>class</code>和<code>extends</code>只能起语法糖的功效，它的效果类似于上文所说的<code>call/apply</code>+中间件继承的混合继承方法，其本质还是基于原型链的继承（例如上文的<code>Child</code>类在<code>extends</code>时，<code>Parent</code>仍然可以是一个传统的构造函数，或者打印各个<code>class</code>，其本质还是<code>function</code>）。因此，熟悉其他继承方法，对于理解<code>ES6</code>及后续的继承方法还是很有用的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/05/JavaScript中检测数据类型的方法/" itemprop="url">
                  JavaScript中检测数据类型的方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-05T10:35:54+08:00" content="2016-09-05">
              2016-09-05
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>检测数据类型的方法不外乎4种，即</p>
<ol>
<li><code>typeof</code></li>
<li><code>instanceof</code></li>
<li><code>constructor</code></li>
<li><code>Object.prototype.toString</code></li>
</ol>
<p>4种方法各有优缺点，本文将分别介绍4中方法的用法即各自适用的场景。</p>
<h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><p><code>typeof</code>是<code>JS</code>提供的检测数据类型的原生方法，返回数据类型的全小写。用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = &apos;a&apos;;</div><div class="line">console.log(typeof a);// string</div></pre></td></tr></table></figure></p>
<p>它对基本数据类型的检测还是比较靠谱的，但是对于引用数据类型，除了<code>function</code>它的返回值基本都是<code>object</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">console.log(typeof &apos;1&apos;); // string</div><div class="line">console.log(typeof 1); // number</div><div class="line">console.log(typeof true); // boolean</div><div class="line">console.log(typeof undefined); // undefined</div><div class="line">console.log(typeof null); // object</div><div class="line">console.log(typeof &#123;&#125;); // object</div><div class="line">console.log(typeof new Date()); // object</div><div class="line">console.log(typeof new Function()); // function</div></pre></td></tr></table></figure></p>
<p>值得注意的是，<code>typeof null</code>返回的是<code>object</code>。</p>
<p>由于<code>typeof</code>这一特性，一般我们只在检测函数或基本数据类型时使用<code>typeof</code>。</p>
<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code>翻译为中文就是“……的实例”，它的作用是判断某个对象是否是某一类的实例，因此它只能对引用数据类型使用。其用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = [];</div><div class="line">console.log(a instanceof Array); // true</div></pre></td></tr></table></figure></p>
<p>返回值如果为<code>true</code>则表示当前对象是这个类的一个实例。</p>
<p><code>instanceof</code>是根据原型链来进行查找的，即如果<code>a.__proto__</code>等于<code>Array.prototype</code>，则认为<code>a</code>是<code>Array</code>的一个实例。但这个方法会顺着原型链一直进行比对，直到找不到才返回<code>false</code>，因此所有的对象<code>instanceof Object</code>得到的结果都为<code>true</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">console.log([] instanceof Object);</div><div class="line">console.log(new Function() instanceof Object);</div><div class="line">console.log(new Date() instanceof Object);</div></pre></td></tr></table></figure></p>
<p>综上所述，<code>instanceof</code>只能用来判断某个类是否在某一对象的原型链上，而不能实际获取这个对象的类型。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>由于每个实例在通过<code>new</code>创建的时候都会在其<code>__proto__</code>上带有一个<code>constructor</code>属性，表明它的构造函数。因此，通过某个实例的构造函数，便可以切实的获取某个对象的类型。其用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let a = [];</div><div class="line">console.log(a.constructor == Array);</div></pre></td></tr></table></figure></p>
<p>这种判断类型的方法也只针对引用数据而言。</p>
<p>这种方法虽然可以切实获取对象的数据类型，但是有时候，对于自定义的类，原型上的<code>constructor</code>是可以被修改的，因此用于<code>JS</code>内置类型的判断比较靠谱。</p>
<h2 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h2><p><code>toString</code>是<code>Object</code>原型上的方法，它会返回运行时<code>this</code>指向的类型，因此如果想获取某个对象的类型，需要使用<code>call</code>来改变<code>this</code>的指向。具体用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(Object.prototype.toString.call(&#123;&#125;)); // [object Object]</div><div class="line">console.log(Object.prototype.toString.call(new Date())); // [object Date]</div><div class="line">console.log(Object.prototype.toString.call(new Array())); // [object Array]</div><div class="line">console.log(Object.prototype.toString.call(new Function())); // [object Function]</div></pre></td></tr></table></figure></p>
<p>这种方法的好处是可以直接返回类型的字符串，不足之处是这种方法只对<code>JS</code>内置的类有效，无法判断自定义的类，因此在判断数组、时间等内置对象的时候使用较多。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="杨宇豪" />
          <p class="site-author-name" itemprop="name">杨宇豪</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">杨宇豪</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
